I. MaxMemory.java

1. -Xmx512m

	`Max memory: 494 MB`

-Xmx задаёт максимальный размер кучи, поэтому размер стал равен 512 МБ.

2. -Xmx512m -Xms512m

	`Max memory: 494 MB`

-Xms задаёт начальный (минимальный) размер кучи. Разница лишь в том, что теперь начальная куча (-Xms) тоже 512 МБ, 
т.е. при старте JVM сразу выделит полный объём, но метод maxMemory() всё так же покажет ту же верхнюю границу.

3. -Xmx512m -Xms512m -XX:+PrintGCDetails

`Max memory: 494 MB[0.099s][info   ][gc,heap,exit] Heap
[0.099s][info   ][gc,heap,exit]  def new generation   total 157248K, used 28021K [0x00000000e0000000, 0x00000000eaaa0000, 0x00000000eaaa0000)
[0.099s][info   ][gc,heap,exit]   eden space 139776K,  20% used [0x00000000e0000000, 0x00000000e1b5d5a8, 0x00000000e8880000)
[0.099s][info   ][gc,heap,exit]   from space 17472K,   0% used [0x00000000e8880000, 0x00000000e8880000, 0x00000000e9990000)
[0.099s][info   ][gc,heap,exit]   to   space 17472K,   0% used [0x00000000e9990000, 0x00000000e9990000, 0x00000000eaaa0000)
[0.099s][info   ][gc,heap,exit]  tenured generation   total 349568K, used 0K [0x00000000eaaa0000, 0x0000000100000000, 0x0000000100000000)
[0.099s][info   ][gc,heap,exit]    the space 349568K,   0% used [0x00000000eaaa0000, 0x00000000eaaa0000, 0x00000000eaaa0200, 0x0000000100000000)
[0.099s][info   ][gc,heap,exit]  Metaspace       used 1070K, committed 1280K, reserved 1114112K
[0.099s][info   ][gc,heap,exit]   class space    used 85K, committed 192K, reserved 1048576K`

а) Вывод из кода: Max memory: 494 MB.

Это результат вызова Runtime.getRuntime().maxMemory(), который показывает около 494 МБ, а не ровно 512 МБ. Разница возникает из‑за внутренних выравниваний и резервирований в JVM — HotSpot зачастую не показывает «в лоб» значение -Xmx.

б) Разбиение Heap (кучи) на поколения:

New generation (молодое поколение) «total 157248K» (примерно 153 МБ), внутри него:
Eden space: 139776K (~136 МБ)
From space: 17472K (~17 МБ)
To space: 17472K (~17 МБ)
Tenured generation (старшее поколение) «total 349568K» (~341 МБ)
Суммарно выходит около 153 МБ + 341 МБ = 494 МБ. Именно это (с учётом мелких округлений) и отражается в логе — совпадает с «Max memory: 494 MB».


с) Metaspace:
Отдельно показаны: used 1070K, committed 1280K, reserved 1114112K.
Metaspace (и Class space) не входят в maxMemory() — оно ограничивает только heap.

4. -Xms512m -Xmx512m -XX:SurvivorRatio=100
   
  	`Max memory: 510 MB`
   
   Параметр -XX:SurvivorRatio=100 говорит о том, как именно делятся пространства Eden и Survivor внутри молодого поколения. Но это внутреннее деление всё той же кучи.
6. -Xmx512m -XX:+UseG1GC
   
    `Max memory: 512 MB`
   
   UseG1GC включает новый сборщик мусора G1, который иначе управляет кучей (разделяет её на регионы)
8. 
II. Phantom references
1. Без -Dphantom.refs=true, при маленькой куче 24 МБ.
Почти нет частых сборок мусора, потому что в итоге не расходуется память на новые объекты (по сути, все PhantomReference указывают на один и тот же substitute).

2. С -Dphantom.refs=true, при куче 24 МБ.
Создаётся множество короткоживущих объектов, каждый завернут в PhantomReference. Память быстро заполняется -> частые GC.

3. С -Dphantom.refs=true, но уже при куче 64 МБ
Та же логика, что и в п. 2, но из-за большего размера кучи сборки мусора происходят реже.

4. С -Dphantom.refs=true и -Dno.ref.clearing=true, при куче 64 МБ
Объекты всё так же живут недолго, но сами PhantomReference не удаляются из ReferenceQueue, копятся и занимают память. Итог – либо чаще GC, либо при длительном запуске возможна утечка (OutOfMemoryError), если очередь растёт быстрее, чем сборщик успевает что-либо очистить.

III. Premature promotion
1. Default heap (не указано -Xmx), MaxTenuringThreshold=1.
Сборок Minor будет какое-то среднее количество.
Full GC зависит от того, насколько на самом деле большая (или маленькая) дефолтная куча. Часто первых 15–30 с может хватить, чтобы не достичь Full GC, но это зависит от машины.

2. C -Xmx24m, New=16m, MaxTenuringThreshold=1
Из-за маленькой кучи будут частые Minor GC, а из-за маленького OldGen (≈8 МБ) и низкого тенуринга — частые Full GC при быстром наполнении OldGen.

3. -Xmx64m, New=32m, MaxTenuringThreshold=1
Больше памяти -> реже Full GC (или вообще может не случиться за 15–30 с).
Minor GC будут происходить регулярно, но реже, чем в п. 2 (т.к. Eden 32 МБ).

4. -Dmax.chunks=1000, -Xmx24m, New=16m, MaxTenuringThreshold=1
Снова маленькая куча, но быстреее очищаются ссылки (пороги 1000 вместо 10000).
Много Minor GC, но Full GC может быть меньше, чем в пункте 2, потому что объекты не успевают долго оставаться в accumulatedChunks.

5. -Xmx64m, New=32m, +NeverTenure
Не продвигаем объекты в OldGen.
Очень частые Minor GC, чтобы чистить Eden/Survivor.
При переполнении молодых поколений живыми объектами может срабатывать Full GC (хотя по идее NeverTenure пытается всё держать в YoungGen, на практике при очень сильном заполнении возможны Full GC).


IV. Soft references

1. Без -Dsoft.refs=true.
Мы фактически используем один и тот же объект substitute для всех SoftReference, поэтому памяти уходит совсем мало. Сборок мусора (особенно Full GC) будет минимум.

2. С -Dsoft.refs=true, но при -Xmx24m
Каждый новый объект действительно живёт в SoftReference.
Память небольшая, Eden быстро заполняется: результат — частые Minor GC, а при попытках переместить живые объекты в OldGen (около 8 МБ) иногда может доходить и до Full GC.
Однако SoftReference будут убиваться сборщиком мусора при нехватке памяти, так что часто объекты даже не дойдут до OldGen, а будут сброшены в Minor GC.

3. С -Dsoft.refs=true при -Xmx64m
Больше памяти (64 МБ, из них 32 МБ в YoungGen).
Minor GC происходят реже, Full GC может вообще не наблюдаться в первые 15–30 с, так как GC имеет больше пространства, а при нехватке — мягкие ссылки очистятся раньше, чем случится полный сбор.

V. Weak references

1. Без -Dweak.refs=true
Все WeakReference указывают на один объект substitute.
Памть расходуется минимально, сборок мусора (особенно Full GC) практически нет.

2. С -Dweak.refs=true, -Xmx24m:
Каждый объект живет в WeakReference и легко освобождается на Minor GC.
Из-за маленького YoungGen (16 МБ) объекты быстро заполняют его -> частые Minor GC, но объекты удляются сразу, так что OldGen почти не растёт -> Full GC либо мало, либо нет

3. С -Dweak.refs=true, -Xmx64m:
Та же ситуация со слабыми ссылками, но YoungGen больше (32 МБ) -> Minor GC реже, Full GC практически не встречается, объекты быстро собираются при первой Minor GC после потери сильной ссылки.

