I. 

II. Phantom references
1. Без -Dphantom.refs=true, при маленькой куче 24 МБ.
Почти нет частых сборок мусора, потому что в итоге «не расходуется» память на новые объекты (по сути, все PhantomReference указывают на один и тот же substitute).

2. С -Dphantom.refs=true, при куче 24 МБ.
Создаётся множество короткоживущих объектов, каждый завернут в PhantomReference. Память быстро заполняется → частые GC.

3. С -Dphantom.refs=true, но уже при куче 64 МБ
Та же логика, что и в п. 2, но из-за большего размера кучи сборки мусора происходят реже.

4. С -Dphantom.refs=true и -Dno.ref.clearing=true, при куче 64 МБ
Объекты всё так же живут недолго, но сами PhantomReference не удаляются из ReferenceQueue, копятся и занимают память. Итог – либо чаще GC, либо при длительном запуске возможна утечка (OutOfMemoryError), если очередь растёт быстрее, чем сборщик успевает что-либо очистить.

III. Premature promotion
1. Default heap (не указано -Xmx), MaxTenuringThreshold=1.
Сборок Minor будет какое-то «среднее» количество.
Full GC зависит от того, насколько на самом деле большая (или маленькая) дефолтная куча. Часто первых 15–30 с может хватить, чтобы не достичь Full GC, но это зависит от машины.

2. C -Xmx24m, New=16m, MaxTenuringThreshold=1
Из-за маленькой кучи будут частые Minor GC, а из-за маленького OldGen (≈8 МБ) и низкого тенуринга — частые Full GC при быстром наполнении OldGen.

3. -Xmx64m, New=32m, MaxTenuringThreshold=1
Больше памяти -> реже Full GC (или вообще может не случиться за 15–30 с).
Minor GC будут происходить регулярно, но реже, чем в п. 2 (т.к. Eden 32 МБ).

4. -Dmax.chunks=1000, -Xmx24m, New=16m, MaxTenuringThreshold=1
Снова маленькая куча, но быстреее очищаются ссылки (пороги 1000 вместо 10000).
Много Minor GC, но Full GC может быть меньше, чем в пункте 2, потому что объекты не успевают долго «застревать» в accumulatedChunks.

5. -Xmx64m, New=32m, +NeverTenure
Не продвигаем объекты в OldGen.
Очень частые Minor GC, чтобы чистить Eden/Survivor.
При переполнении молодых поколений живыми объектами может срабатывать Full GC (хотя «по идее» NeverTenure пытается всё держать в YoungGen, на практике при очень сильном заполнении возможны Full GC).


IV. Soft references

1. Без -Dsoft.refs=true.
Мы фактически используем один и тот же объект substitute для всех SoftReference, поэтому памяти уходит совсем мало. Сборок мусора (особенно Full GC) будет минимум.

2. С -Dsoft.refs=true, но при -Xmx24m
Каждый новый объект действительно «живёт» в SoftReference.
Память небольшая, Eden быстро заполняется: результат — частые Minor GC, а при попытках переместить живые объекты в OldGen (около 8 МБ) иногда может доходить и до Full GC.
Однако SoftReference будут убиваться сборщиком мусора при нехватке памяти, так что часто объекты даже не дойдут до OldGen, а будут сброшены в Minor GC.

3. С -Dsoft.refs=true при -Xmx64m
Больше памяти (64 МБ, из них 32 МБ в YoungGen).
Minor GC происходят реже, Full GC может вообще не наблюдаться в первые 15–30 с, так как GC имеет больше пространства, а при нехватке — «мягкие» ссылки очистятся раньше, чем случится полный сбор.

V. Weak references

1. Без -Dweak.refs=true
Все WeakReference указывают на один объект substitute.
Память расходуется минимально, сборок мусора (особенно Full GC) практически нет.

2. С -Dweak.refs=true, -Xmx24m:
Каждый объект «живет» в WeakReference и легко освобождается на Minor GC.
Из-за маленького YoungGen (16 МБ) объекты быстро заполняют его → частые Minor GC, но объекты «убиваются» сразу, так что OldGen почти не растёт → Full GC либо мало, либо нет.

3. С -Dweak.refs=true, -Xmx64m:
Та же ситуация со слабыми ссылками, но YoungGen больше (32 МБ) → Minor GC реже, Full GC практически не встречается, объекты быстро собираются при первой Minor GC после потери сильной ссылки.

